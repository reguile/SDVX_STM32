/**
  ******************************************************************************
  * @file    main.c
  * @author  Ryan Guile
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#include "stm32l100xc.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define SWITCH_COUNT		1
#define ENCODER_COUNT		1

#define CLOCK_RATE			16000000		// System clock rate in Hz
#define DELAY				10				// Delay in ms for timer

typedef struct {
	GPIO_TypeDef* port;			// Port that the button and LED pins are on. I'm assuming both pins are on the same port but I probably shouldn't. Oh well.
	uint16_t switchPin;
	uint16_t lightPin;
	char key;					// key that is sent when the button is pressed
} switch_t;


typedef struct {
	GPIO_TypeDef* port;			// Port that the encoder pins are on. I'm assuming both pins are on the same port but I probably shouldn't. Oh well.
	uint16_t pin1;
	uint16_t pin2;
	char posKey;				// The key that is pressed when the rotation is clockwise
	char negKey;				// The key that is pressed when the rotation is counter-clockwise
	volatile uint16_t state;	// Represents the state of the encoder. Bits 0 and 1 represent the old state, bits 2 and 3 represent the new state.
	volatile int16_t pos;		// Position of the encoder
} encoder_t;

void Clock_Init(void);
void GPIO_Init(void);
void Timer_Init(void);
void delay(uint16_t ms);
int16_t encoderRead(encoder_t *encoder);

// This structure represents all of the pins and values
// associated with each switch.
// The structure contains the switch input pin, corresponding LED pin,
// and the key that is to be pressed when the switch is hit.
switch_t switches[SWITCH_COUNT] = {
  {GPIOA, 0, 1, 'l'}, // START
//  {GPIOA, 2, 3, 'd'}, // A
//  {GPIOA, 4, 5, 'f'}, // B
//  {GPIOA, 6, 7, 'j'}, // C
//  {GPIOA, 8, 9, 'k'}, // D
//  {GPIOA, 10, 13, 'c'}, // FX A
//  {GPIOA, 14, 15, 'm'}, // FX B
};

encoder_t encoders[ENCODER_COUNT] = {
	{GPIOB, 0, 1, 'q', 'w', 0, 0}
	//{GPIOB, 2, 3, 'o', 'p', 0, 0}
};

int main(void)
{
	Clock_Init();
	GPIO_Init();
	Timer_Init();

	volatile int enPos = 0;

	while(1) {

		// Poll for Button state, set LED and key press if it's pressed
		for(int i=0; i<SWITCH_COUNT; i++) {

			// Active low signal, check if the button was pressed
			if(!(switches[i].port->IDR & (0x1U << switches[i].switchPin))) {
				switches[i].port->ODR |= (0x1U << switches[i].lightPin);
				// pressKey(switches[i].key)

			}

			else{
				switches[i].port->ODR &= ~(0x1U << switches[i].lightPin);
				// releaseKey(switches[i].key)
			}
		}

		for(int i = 0; i < ENCODER_COUNT; i++) {

			// Clear position before reading, we only care about the direction
			// of movement not the overall position
			encoders[i].pos = 0;

			enPos = encoderRead(&encoders[i]);

			// Clockwise motion
			if(enPos > 0) {
				//pressKey(encoder[i].posKey)
				// LED for testing, remove
				GPIOC->ODR |= GPIO_ODR_ODR_8;
			}

			// Counter-clockwise motion
			else if(enPos < 0) {
				//pressKey(encoder[i].negKey)
				// LED for testing, remove
				GPIOC->ODR |= GPIO_ODR_ODR_9;
			}

			// no movement
			// just release both keys so we don't have to keep track of
			// the direction of motion before this
			else {
				//releaseKey(encoder[i].posKey)
				//releaseKey(encoder[i].negKey)
				GPIOC->ODR &= ~GPIO_ODR_ODR_8;
				GPIOC->ODR &= ~GPIO_ODR_ODR_9;
			}

		}

		delay(DELAY);		// delay for debouncing
	}
}

void Clock_Init(void) {

	// Initialize system clocks
	// System uses 16 MHz HSI clock
	// USB uses 48 MHz clock generated by a scaled 8 MHz external crystal
	RCC->CR |= (RCC_CR_PLLON + RCC_CR_HSEON + RCC_CR_HSEBYP + RCC_CR_HSION);
	RCC->CFGR |= (RCC_CFGR_SW_HSI + RCC_CFGR_PLLSRC_HSE + RCC_CFGR_PLLMUL12 + RCC_CFGR_PLLDIV2);

	}

// Exactly what it says
void GPIO_Init(void) {

	// Initialize GPIOA Clock for switches and LEDs
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

	// Initialize GPIOB Clock for encoders
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

	// Port C used for test purposes, delete later
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN;

	// Reset GPIO level
	GPIOA->ODR = 0;
	GPIOB->ODR = 0;

	// testing, delete later
	GPIOC->MODER |= GPIO_MODER_MODER8_0 + GPIO_MODER_MODER9_0;

	// Set LEDs as output, leave the rest as inputs
	// Also set switch pins as pull-ups
	// Because each pin has two config bits, we must shift accordingly
	for(int i=0; i<SWITCH_COUNT; i++) {
		switches[i].port->MODER |= (0x1UL << (2 * switches[i].lightPin));
		switches[i].port->PUPDR |= (0x1UL << (2 * switches[i].switchPin));
	}

	// Set encoder pins as pull-up
	for(int i=0; i<ENCODER_COUNT; i++) {
		encoders[i].port->PUPDR |= (0x1UL << (2 * encoders[i].pin1));
		encoders[i].port->PUPDR |= (0x1UL << (2 * encoders[i].pin2));
	}
}

void Timer_Init() {
	// Enable clock
	RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;

	// Enable interrupt
	NVIC_SetPriority(TIM6_IRQn, 0x01);
	NVIC_EnableIRQ(TIM6_IRQn);

	// Make sure counter is off
	TIM6->CR1 &= ~(TIM_CR1_CEN);

	// Reset timer
	RCC->APB1RSTR |= RCC_APB1RSTR_TIM6RST;
	RCC->APB1RSTR &= ~RCC_APB1RSTR_TIM6RST;

	// Prescalar set for timer to count up every millisecond
	TIM6->PSC = (uint16_t) (CLOCK_RATE / 1000);
	TIM6->ARR = DELAY;

	TIM6->EGR |= TIM_EGR_UG;
	TIM6->DIER |= TIM_DIER_UIE;



}

//                           _______         _______
//               Pin1 ______|       |_______|       |______ Pin1
// negative <---         _______         _______         __      --> positive
//               Pin2 __|       |_______|       |_______|   Pin2

		//	new		new		old		old
		//	pin2	pin1	pin2	pin1	Result
		//	----	----	----	----	------
		//	0		0		0		0		no movement
		//	0		0		0		1		+1
		//	0		0		1		0		-1
		//	0		0		1		1		+2  (assume pin1 edges only)
		//	0		1		0		0		-1
		//	0		1		0		1		no movement
		//	0		1		1		0		-2  (assume pin1 edges only)
		//	0		1		1		1		+1
		//	1		0		0		0		+1
		//	1		0		0		1		-2  (assume pin1 edges only)
		//	1		0		1		0		no movement
		//	1		0		1		1		-1
		//	1		1		0		0		+2  (assume pin1 edges only)
		//	1		1		0		1		-1
		//	1		1		1		0		+1
		//	1		1		1		1		no movement
int16_t encoderRead(encoder_t *encoder) {
	uint16_t state = encoder->state;

	state &= 3;		// Only want the first 2 bits
	if (encoder->port->IDR & (0x1U << encoder->pin1)) {
		state |= 4;		// Store pin 1 value in bit 3
	}
	if (encoder->port->IDR & (0x1U << encoder->pin2))	{
		state |= 8;		// Store pin 2 value in bit 4
	}

	// These states are taken from the chart above
	switch (state) {
		case 1: case 7: case 8: case 14:
			encoder->pos++;
			break;
		case 2: case 4: case 11: case 13:
			encoder->pos--;
			break;
		// commenting out these 2 cases as it will sometime cause wrong reads.
		// TODO calibrate rate of reading encoder
		// Accuracy doesn't matter very much for this application but might as well make it robust.
		case 3: case 12:
			//encoder->pos += 2;
			break;
		case 6: case 9:
			//encoder->pos -= 2;
			break;
	}

	// Set the new state as the old state for the next read
	encoder->state = (state >> 2);

	return encoder->pos;

}


// Uses a timer to generate a fairly accurate delay in milliseconds
void delay(uint16_t ms) {
	TIM6->ARR = ms;
	TIM6->CR1 |= TIM_CR1_CEN;
	while(TIM6->CR1 & TIM_CR1_CEN) {
		// Check whether the timer is still enabled; if it isn't, that means
		// we've cleared it through the interrupt handler
	}

}

void TIM6_IRQHandler(void) {
	// Clear the interrupt flag
	if(TIM6->SR & TIM_SR_UIF) {
		TIM6->SR &= ~TIM_SR_UIF;
	}

	// disable the counter
	TIM6->CR1 &= ~TIM_CR1_CEN;
}
